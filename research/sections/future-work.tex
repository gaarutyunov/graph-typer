In this work, we explored the application of Graph Transformers for type inference.
The versatile architecture of the proposed solution lets us explore other tasks.

\subsection{Universal code graph representation}\label{subsec:universal-code-graph-representation}

If a universal version of graph code representation is used, similar to CPG~\cite{yamaguchi2014modeling},
we can train the model for multiple programming languages~\cite{wang_unified_2022}.
However, because of the differences of type systems, separate models would be trained for each programming language for better results.

\subsection{Detecting duplicates}\label{subsec:detecting-duplicates}

It is crucial to address the issue of duplicates in source code to train neural networks for code~\cite{allamanis2020typilus,mir_type4py_2021}.
Several architectures have already been used for such task: Transformers~\cite{zhang2023efficient}, GNNs~\cite{wang_detecting_2020} and RNNs~\cite{yasaswi2017plagiarism}.
We believe that the graph representation obtained with our model can be successfully used for code clone detection.

\subsection{Code and docstring generation}\label{subsec:code-generation}

Firstly, we can train the model using a technique similar to generative pretrained models~\cite{radford_language_2019,brown_language_2020} or masked language models~\cite{tipirneni_structcoder_2022} to generate code.
Secondly, our model can be used to generate code summarization or docstring generation~\cite{barone_parallel_2017,liu_haconvgnn_2021}.
This could only be possible if we adapt some of the approach discussed in the previous Section~\ref{subsec:absence-of-natural-language-information}

\subsection{Vulnerability and error detection}\label{subsec:vulnerability-and-error-detection}

Another useful task is to detect errors and generate fixes~\cite{bhatia_automated_2016,marginean_sapfix_2019}.
This is possible by simply adding features that contain error indication or types.
Similar approach can be used to scan for vulnerabilities~\cite{li_vuldeepecker_2018,russell_automated_2018,nguyen_regvd_2021}.
Fixing bugs and vulnerabilities, however, would imply that the graph structure could change.
Therefore, solving this task would require the model to be modified for graph generation~\cite{khajenezhad2022gransformer}.

\subsection{Refactoring}\label{subsec:refactoring}

Finally, we can extend our model with information about changes to analyze them and propose refactoring possibilities~\cite{cabrera_lozoya_commit2vec_2021}.
This goal could be achieved by using the model from the previous Section~\ref{subsec:vulnerability-and-error-detection}.